// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information
namespace DotNetNuke.Internal.SourceGenerators;

using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

/// <summary>A source generator which turns <see cref="DnnDeprecatedAttribute"/> into <see cref="ObsoleteAttribute"/>.</summary>
[Generator]
public class DnnDeprecatedGenerator : IIncrementalGenerator
{
    private const string DnnDeprecatedTypeName = "DotNetNuke.Internal.SourceGenerators.DnnDeprecatedAttribute";

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: HasAttribute,
                transform: GetIfHasDeprecatedAttribute)
            .Where(static classDeclaration => classDeclaration is not null);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(classes.Collect()), Execute);
    }

    private static void Execute(SourceProductionContext context, (Compilation compilation, ImmutableArray<MemberDeclarationSyntax?> members) value)
    {
        var members = value.members;
        if (members.IsDefaultOrEmpty)
        {
            return;
        }

        var compilation = value.compilation;

        var dnnDeprecatedType = compilation.GetTypeByMetadataName(DnnDeprecatedTypeName);
        if (dnnDeprecatedType is null)
        {
            return;
        }

        foreach (var memberDeclaration in members)
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            if (memberDeclaration is null)
            {
                return;
            }

            if (ReportDiagnosticIfNotPartial(context, memberDeclaration))
            {
                continue;
            }

            var semanticModel = compilation.GetSemanticModel(memberDeclaration.SyntaxTree);
            var symbol = ModelExtensions.GetDeclaredSymbol(semanticModel, memberDeclaration);
            if (symbol is null)
            {
                continue;
            }

            var deprecation = GetDeprecation(symbol, dnnDeprecatedType);
            if (deprecation is null)
            {
                continue;
            }

            var namespaceName = GetNamespace(memberDeclaration);
            var containingTypes = new Stack<TypeDeclarationSyntax>();
            var parent = memberDeclaration.Parent;
            while (parent is TypeDeclarationSyntax parentType)
            {
                containingTypes.Push(parentType);
                parent = parent.Parent;
            }

            var stringWriter = new StringWriter();
            var writer = new IndentedTextWriter(stringWriter);

            writer.WriteLine("// <auto-generated/>");
            writer.WriteLine($"namespace {namespaceName};");
            writer.WriteLine();

            foreach (var containingType in containingTypes)
            {
                writer.WriteLine($"partial {containingType.Keyword} {containingType.Identifier}");
                writer.WriteLine("{");
                writer.Indent++;
            }

            writer.WriteLine($"""
[global::System.Obsolete("Deprecated in DotNetNuke {deprecation.MajorVersion}.{deprecation.MinorVersion}.{deprecation.PatchVersion}. {deprecation.Replacement.TrimEnd('.')}. Scheduled for removal in v{deprecation.RemovalVersion}.0.0.")]
""");
            if (memberDeclaration is TypeDeclarationSyntax typeDeclaration)
            {
                writer.WriteLine($"partial {typeDeclaration.Keyword} {typeSymbol.Name}");
                    writer.WriteLine("{");
                    writer.WriteLine("}");
            }

            foreach (var unused in containingTypes)
            {
                writer.Indent--;
                writer.WriteLine("}");
            }

            writer.WriteLine();

            context.AddSource(GetHintName(namespaceName, containingTypes, symbol), stringWriter.ToString());
        }
    }

    private static string GetHintName(string namespaceName, IEnumerable<TypeDeclarationSyntax> containingTypes, ISymbol symbol)
    {
        var hintNameBuilder = new StringBuilder(namespaceName);
        hintNameBuilder = containingTypes.Aggregate(
            hintNameBuilder,
            (builder, type) => builder.Append($".{type.Identifier}"));
        hintNameBuilder.Append($".{symbol.Name}");
        return hintNameBuilder.ToString();
    }

    private static bool ReportDiagnosticIfNotPartial(SourceProductionContext context, MemberDeclarationSyntax declaration)
    {
        var isPartial = false;
        foreach (var modifier in declaration.Modifiers)
        {
            if (modifier.IsKind(SyntaxKind.PartialKeyword))
            {
                isPartial = true;
                break;
            }
        }

        if (isPartial)
        {
            return false;
        }

        var diagnostic = Diagnostic.Create(
            new DiagnosticDescriptor(
                "DNN1001",
                "Must be partial",
                "The member that the DnnDeprecated attribute is applied to must be partial",
                "Usage",
                DiagnosticSeverity.Error,
                isEnabledByDefault: true),
            declaration.GetLocation());
        context.ReportDiagnostic(diagnostic);
        return true;
    }

    private static DnnDeprecatedAttribute? GetDeprecation(ISymbol typeSymbol, ISymbol dnnDeprecatedType)
    {
        foreach (var attribute in typeSymbol.GetAttributes())
        {
            if (!dnnDeprecatedType.Equals(attribute.AttributeClass, SymbolEqualityComparer.Default))
            {
                continue;
            }

            var args = attribute.ConstructorArguments;
            foreach (var arg in args)
            {
                if (arg.Kind == TypedConstantKind.Error)
                {
                    return null;
                }
            }

            var deprecation = new DnnDeprecatedAttribute(
                (int)args[0].Value!,
                (int)args[1].Value!,
                (int)args[2].Value!,
                (string)args[3].Value!);

            foreach (var arg in attribute.NamedArguments)
            {
                if (!arg.Key.Equals(nameof(DnnDeprecatedAttribute.RemovalVersion), StringComparison.Ordinal))
                {
                    continue;
                }

                if (arg.Value.Kind == TypedConstantKind.Error)
                {
                    return null;
                }

                if (deprecation is not null)
                {
                    deprecation.RemovalVersion = (int)arg.Value.Value!;
                    return deprecation;
                }
            }

            return deprecation;
        }

        return null;
    }

    private static string GetNamespace(SyntaxNode classDeclaration)
    {
        var memberNamespace = classDeclaration.Parent;
        while (memberNamespace is not null &&
               memberNamespace is not NamespaceDeclarationSyntax &&
               memberNamespace is not FileScopedNamespaceDeclarationSyntax)
        {
            memberNamespace = memberNamespace.Parent;
        }

        if (memberNamespace is not BaseNamespaceDeclarationSyntax namespaceParent)
        {
            return string.Empty;
        }

        var namespaceName = namespaceParent.Name.ToString();
        while (true)
        {
            if (namespaceParent.Parent is not NamespaceDeclarationSyntax namespaceParentParent)
            {
                break;
            }

            namespaceParent = namespaceParentParent;
            namespaceName = $"{namespaceParent.Name}.{namespaceName}";
        }

        return namespaceName;
    }

    private static bool HasAttribute(SyntaxNode node, CancellationToken token)
    {
        return node is MemberDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static MemberDeclarationSyntax? GetIfHasDeprecatedAttribute(GeneratorSyntaxContext context, CancellationToken token)
    {
        var member = (MemberDeclarationSyntax)context.Node;
        foreach (var attributeList in member.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                token.ThrowIfCancellationRequested();
                if (context.SemanticModel.GetSymbolInfo(attribute).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue;
                }

                var attributeType = attributeSymbol.ContainingType;
                if (attributeType.ToDisplayString().Equals(DnnDeprecatedTypeName, StringComparison.Ordinal))
                {
                    return member;
                }
            }
        }

        return null;
    }
}
